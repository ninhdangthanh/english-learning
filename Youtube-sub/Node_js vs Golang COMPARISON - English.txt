
Have you ever wondered which technology stands behind the services we regularly use? Well, it's a great way to start small talk and transform it into in-depth research, just like the Jelix teammates did recently. As they used to share an Uber to the Jelix office, one of our developers broke the silence with an interesting question: "Which platform did Uber developers use to create the app?"

Interestingly, while most of the Uber app was initially written in Node.js and Python back in 2010, Uber decided to transition its new engineering projects to GoLang in 2016. This way, the company aimed to optimize Uber's geofence lookup microservice. But does this mean that GoLang is a more suitable choice for real-time applications like Uber? What are the benefits that Node.js could not deliver as efficiently, leading Uber engineers to opt for GoLang? And did Uber eventually make a mistake leaving Node.js behind?

Driven by curiosity, the Jelix teammates couldn't stop thinking about it. So, in this video, we'll be sharing the takeaways from their research findings based on the comparison between the Node.js and GoLang platforms. Welcome to another video by Jelix, a software development partner for industry leaders. We post weekly educational videos on tech in just 5 minutes, so sit back, enjoy, and don't forget to subscribe. Also, use the "Super Thanks" feature to support our channel, and make sure you watch till the end to discover the surprising results Uber achieved after switching platforms!

So, what made Uber make this transition? Let’s dive into the details. We’ll compare the journeys of two platforms—GoLang and Node.js—and to ensure we’ve covered all the bases, we’ll make several stops during the ride: performance, concurrency, scalability, learning curve, and popularity. So, buckle up and enjoy the ride!

Let's start with the first stop—performance. Speaking of GoLang, this platform shines in scenarios where raw CPU performance, efficient resource usage, and parallelism are essential. GoLang is considered a raw performance leader for several reasons, including compilation to machine code, efficient memory management, native support for concurrency, strong typing, an extensive standard library, low-level control, and robust parallelism capabilities, to name a few. In Uber’s case, GoLang's strong static typing and raw CPU performance aligned with Uber's algorithms.

When compared, Node.js often performs worse for CPU-bound tasks because it operates in a single-threaded event loop, which can block the event loop and impact overall performance. However, Node.js is a strong choice for I/O-bound tasks and real-time apps, thanks to its non-blocking event-driven architecture. Based on these factors, the Jelix team would rate GoLang’s performance a 5, while Node.js would score a 4.

Alright, let's move on to the second stop in the analysis—concurrency. The data shows that Node.js doesn't match the level of concurrency and efficiency provided by GoLang's concurrency features, and that's due to its event-driven model. GoLang, on the other hand, offers native support for concurrency with goroutines and channels, making it more efficient in this aspect.

Our next stop is scalability. The Jelix team would give GoLang five stars and Node.js four stars. GoLang’s goroutines and channels allow it to effectively utilize multicore processors and distribute tasks among them, resulting in improved parallelism and scalability, which Node.js can't match equally. While Node.js can also run in multicore environments and is easy to scale using built-in tools like the Cluster library or external supervisors, GoLang is slightly faster and more scalable due to its native code compilation.

But what about ease of use? The answer isn't so obvious here. The learning curve for GoLang is often considered easier than Node.js, especially for newcomers, thanks to its simplicity, straightforward syntax, and strong typing. Node.js may have a steeper learning curve for those new to asynchronous programming concepts, but developers with prior JavaScript experience may find Node.js more familiar and easier to use.

When it comes to usability, the activity of the community can tell you a lot. Here's what the Jelix team discovered: according to the Stack Overflow survey, Node.js remains one of the most used platforms, while GoLang ranks lower. But it's too early to call Node.js the clear leader. The same survey shows that the interest in learning GoLang outruns Node.js. Furthermore, although GoLang’s community isn’t as large as Node.js's, almost 92% of developers claim to be highly or considerably satisfied with GoLang. The Go survey report shows that 68% of GoLang users are willing to recommend it, and 91% would prefer to use it for their next project.

Now that we’ve covered all the stops, let's get back to the Uber case. Uber began adopting GoLang for specific parts of their system where high concurrency, performance, and efficient resource utilization were critical. The outcome of this switch was impressive—Uber achieved 99.99% uptime and handled a peak load of 170,000 queries per second.

So, as we finish our Uber ride, we can look at the platforms' regular passengers—the companies that use these technologies. And there you have it—a report from our trip. We’ve got you covered, and the ride is on us! Check out our video on the best Node.js frameworks for more insights, and stay tuned for our next videos coming soon. Subscribe and like this video to support us. Bye for now!
