
Rust is a special language; it eliminates an entire class of memory safety bugs at runtime by enforcing a set of rules at compile time. But there's a catch: as a Rust developer, you're constantly bombarded with compile-time errors. Debugging these errors is so common and so frustrating that the Rust community has a name for it—fighting the Borrow Checker.

The number one mistake you can make when learning Rust is attempting to fight the Borrow Checker without being prepared for battle. In the last video, I explained how a part of the Rust compiler, called the Borrow Checker, analyzes your code to ensure it follows a set of rules that ensure memory safety. These rules are called the ownership and borrowing rules. Even though these rules are simple, they can result in a constant stream of errors that will leave you endlessly debugging code instead of shipping features. So in this video, I'll give you three principles of battle you must know in order to win the great war against the Borrow Checker.

With that said, let's get rusty. Principle one: know thy enemy. The Rust Borrow Checker has two important characteristics you need to be aware of—it's basic and conservative. Basic in the sense that it enforces a simple set of rules, and conservative in the sense that it will reject potentially valid code if it can't deterministically prove the code is memory safe. Let me show you what I mean.

We have a user struct with two fields: a user ID and a vector of posts. In `main`, we create a new user instance and then store the user's posts in a variable. Now, let's see what happens when we try to mutate the user ID. Mutating the ID directly on the user struct works without any issues, but mutating the ID by calling the `setID` method results in an error stating "borrow of partially moved value: user." What does "partially moved" mean, and why are we getting this error?

Remember that according to the ownership rules, each value in Rust has an owner, and there can only be one single owner at a time. When we create our user instance, the vector of posts is owned by the posts field. Then, when we define `userPosts` and set it equal to `user.posts`, the vector moves into `userPosts`, and the `posts` struct field is invalidated. `userPosts` is now the new and sole owner of the vector. This is called a partial move because part of the struct is moved while the rest remains usable.

The next line works because we are mutating the part of the struct that wasn't moved. But when we try to call the `setID` method, the Borrow Checker freaks out. This makes sense if we look at the method signature—`setID` accepts a mutable reference to `self`, which is an instance of a user struct. The problem is that getting a mutable reference to a user instance that has partially moved data can cause memory safety issues. Imagine if we tried to access the `posts` field inside the function. Of course, in this case, we are only modifying the `userID` field, but the Borrow Checker doesn't know that. It doesn't analyze the function's implementation; it simply looks at the function signature, checks the basic ownership and borrowing rules, and conservatively rejects code that might violate them.

If it were able to analyze our specific implementation, not only would that complicate the ownership and borrowing rules, but it would also dramatically increase compile times. Understanding that the Borrow Checker is basic and conservative will help prepare you for the battle ahead and give you the mindset needed to win. Principle two: wage war strategically.

Knowing your enemy is a good start, but it's not enough. In order to engage in battle and win, you need a strategy. Here's the simple three-step process I go through anytime I get a compile-time error. Step one: read the error message. I know this sounds obvious, but it's amazing how many times I've started Googling for a solution or started sprinkling `Arc` everywhere before thoroughly reading and understanding the error I'm getting. Making sure you read error messages is very important, especially because, oftentimes, the compiler gives you helpful hints and even solutions.

In this example, we're passing a vector into a function and then attempting to print the vector. We get an error stating "borrowed of moved value: numbers." The compiler tells us which line is throwing the error, where the value was moved, and why it was moved. The compiler also gives us helpful hints with possible solutions, like changing the `process` function to accept a borrowed value or cloning the vector of numbers. And if we need more information about this specific error, the compiler gives us a command we can run, which provides a detailed explanation of the error that includes examples.

Now that we've read the error message thoroughly, we can move on to step two: work through the problem. This is where you reason about the error and try to solve it yourself. In this case, if the `process` function only needs immutable access to the vector, we can pass in a borrowed value. However, in other situations, the solution is not as clear.

In this example, we're attempting to pass a reference to a vector into a newly spawned thread. We get an error stating "borrowed value does not live long enough" and that data has been borrowed for `'static`. This error requires a deeper understanding of Rust, and the compiler doesn't suggest any possible solutions. In situations like this, where you can't reason about the problem without additional help, instead of using Google or Stack Overflow, you can deploy step three: use AI.

I use AI tools every single day for various tasks, including coding, and it's truly a game-changer. For example, I can ask GitHub Copilot to explain this error to me. Because Copilot has access to my code, it'll give me a tailored answer, including the solution and an explanation. Not only that, but I can actually have a conversation with Copilot about my code. Using AI not only to help you write code but also to help you understand and debug code will dramatically improve your productivity.

Now that you know your enemy and have a strategy in place, you're ready for battle. However, battle is costly, and you should only engage the enemy when necessary. Principle three: avoid battle.

The best way to win the battle against the Borrow Checker is to avoid it in the first place. This is by no means easy to do, but here's a general guideline to follow: make it work, make it right, make it fast. The first step is to make sure your code works as intended. Don't worry about making it clean, idiomatic, or performant. Avoid the hard parts of Rust, like lifetimes. Use owned values instead of references, clone data where it makes sense, or use the `Rc` smart pointer for shared ownership, and avoid error handling by simply calling `unwrap`. It's also important to ignore certain areas in Rust that are known to be difficult—things like self-referential structs, advanced data structures like linked lists and graphs, concurrency and parallelism, unsafe Rust, and macros. Okay, you're not that guy, pal. Trust me, you're not that guy.

Once your code is working, you can move on to step two: make it right. This is where you refactor your code to make it more idiomatic. As a bonus, writing idiomatic Rust will help you avoid Borrow Checker errors. Writing idiomatic Rust is a large topic that deserves a video of its own. In fact, I've already made a playlist going over idiomatic Rust, which you can check out. You can also check out the idiomatic Rust GitHub repo, which is a peer-reviewed collection of articles, talks, and repos that teach concise, idiomatic Rust. You can find a link to it in the description of this video.

The last step is to optimize your code for speed, if necessary, which may include using advanced concepts like multiple lifetimes or unsafe Rust. Using this guideline will help you avoid constantly fighting the Borrow Checker and make you feel a lot more productive when writing Rust.

With these three principles of battle—know your enemy, wage war strategically, and avoid battle—you are now equipped to fight the Borrow Checker and win. Before you go, make sure to get your free Rust cheat sheet at letsry.com. Let me know if this video has been helpful by leaving a comment below, give this video a like if you enjoyed it, and subscribe to the channel for more Rust content. Hope you've enjoyed the video, and remember to stay Rusty.
